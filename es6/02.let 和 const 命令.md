# let 和 const 命令

## let 命令

### 不存在变量提升

### 暂时性死区（Temporal dead zone）

typeof 操作符

### 不允许重复声明（Redeclarations）

### 块级作用域

## const 命令

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

如果想将对象冻结，应该使用`Object.freeze`方法。

```javascript
const foo = Object.freeze({})

// 常规模式时，下面一行不起作用；严格模式时，该行会报错
foo.prop = 123
```

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

这里展示的是阮一峰版本，没有考虑 `null`，用 MDN 版本的例子来测会报错。如需使用，采用后两个版本（建议 3）

```javascript
var constantize = obj => {
  Object.freeze(obj)
  Object.keys(obj).forEach((key, i) => {
    if (typeof obj[key] === 'object') {
      constantize(obj[key])
    }
  })
}
```

1. [阮一峰版][1]

1. [MDN 版][2]

1. [30 seconds of code 版][3] :+1:

[1]: http://es6.ruanyifeng.com/#docs/let#%E6%9C%AC%E8%B4%A8
[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#Freezing_arrays
[3]: https://30secondsofcode.org/object#deepfreeze
